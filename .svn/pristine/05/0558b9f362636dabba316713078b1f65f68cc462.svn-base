package Numbermat;

import Numbermat.GUI.MainFrame;
import Numbermat.GUI.Config;
import Numbermat.GUI.UserInputChecker;
import de.nixosoft.jlr.JLRGenerator;
import de.nixosoft.jlr.JLROpener;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JLabel;
import org.scilab.forge.jlatexmath.TeXConstants;
import org.scilab.forge.jlatexmath.TeXFormula;
import org.scilab.forge.jlatexmath.TeXIcon;

/**
 *
 * @author Valdemar Svabensky <395868@mail.muni.cz>
 */
public final class Utils {
    
    public static final String NEWLINE = System.lineSeparator();
    
    private Utils() {
        throw new IllegalStateException(this.getClass().getName() + " class should not be instantiated.");
    }
    
    /**
     * Changes commonly used ASCII math symbols for their LaTeX equivalents.
     * @param input Text
     * @return Text with "\cdot" instead of "*" and "\varphi" instead of "φ".
     */
    public static String prepareBasicMath(final String input) {
        return input.replaceAll("\\*", "\\\\cdot").replaceAll("φ", "\\\\varphi");
    }
    
    /**
     * Changes ASCII math congruences symbols for their LaTeX equivalents.
     * @param input Text
     * @return Text with e.g. "\equiv" instead of "≡" or \pmod{n} instead of "(mod n)"
     */
    public static String prepareCongruencesMath(final String input) {
        String tmp = input.replaceAll("≡", "\\\\equiv");
        tmp = tmp.replaceAll("≢", "\\\\not\\\\equiv");
        tmp = tmp.replaceAll(AlgorithmsSteps.SEPARATOR, "\\\\hline ");
        if (tmp.contains("Kongruence")) {
            tmp = tmp.replaceAll("Kongruence", "&\\\\text{Kongruence");
            tmp = tmp.replaceAll("řešení.", "řešení.}");
        }
        
        final List<String> numbers = matchNumbers(input);
        for (int i = 0; i < numbers.size(); ++i) {
            final String n = numbers.get(i);
            tmp = tmp.replaceAll("\\(mod " + n + "\\)", "\\\\pmod{" + n + "}");
        }
        return tmp;
    }
    
    private static List<String> matchNumbers(final String input) {
        final List<String> numbers = new ArrayList<>();
        Pattern p = Pattern.compile("\\d+");
        Matcher m = p.matcher(input); 
        while (m.find())
            numbers.add(m.group());
        return numbers;
    }
    
    /**
     * Changes ASCII math set symbols for their LaTeX equivalents.
     * @param input Text
     * @return Text with e.g. "\mathbb{Z}_{n}" instead of "Zn"
     */
    public static String prepareSetsMath(final String input) {
        String tmp = input.replaceAll("Z", "\\\\mathbb{Z}_{");
        //tmp = tmp.replaceAll("\\{", "\\\\{");
        //tmp = tmp.replaceAll("\\}", "\\\\}");
        tmp = tmp.replaceAll("\\×", "}^\\\\times");
        tmp = tmp.replaceAll("\\*", "}^\\*");
        if (tmp.contains("Řád")) {
            tmp = tmp.replaceAll("Řád grupy", "\\\\text{Řád grupy}");
            tmp = tmp.replaceAll("Možné řády prvků", "\\\\text{Možné řády prvků}");
            tmp = tmp.replaceAll("Řád prvku", "\\\\text{Řád prvku }");
            tmp = tmp.replaceAll(":", "&\\\\colon");
        }
        return tmp;
    }
    
    /**
     * Searches for substrings of type "(a/b)" and replaces them with LaTeX fractions.
     * Must be called after prepareCongruencesMath()!
     * @param input Text with substrings of type "(a/b)"
     * @return Text with "\frac{a}{b}" instead of "(a/b)"
     */
    public static String prepareFractionsMath(final String input) {
        final List<String> numbers = matchNumbers(input);
        String tmp = input;
        for (int i = 0; i < numbers.size(); ++i) {
            final String n = numbers.get(i);
            tmp = tmp.replaceAll("\\(" + n + "\\/", "\\\\left(\\\\frac{" + n + "}{");
            tmp = tmp.replaceAll("\\(-" + n + "\\/", "\\\\left(\\\\frac{-" + n + "}{");
            tmp = tmp.replaceAll(n + "\\)", n + "}\\\\right)");
        }
        return tmp;
    }
    
    /**
     * Prepares LaTeX align environment.
     * @param input Text
     * @return Text prefixed with "\begin{align}" and ending with "\end{align}" and added & operators.
     */
    public static String prepareAlignMath(final String input) {
        String tmp = input.replaceAll("=", "&=");
        tmp = tmp.replaceAll("\\\\equiv", "&\\\\equiv");
        tmp = tmp.replaceAll("\\\\not&\\\\equiv", "&\\\\not\\\\equiv");
        
        StringBuilder sb = new StringBuilder();
        sb.append("\\begin{align}").append(NEWLINE).append(tmp);
        
        // Insert LaTeX newline symbol: "\\"  at the position of NEWLINE
        final int newLineReplacementBeginning = sb.lastIndexOf("{align}") + 9;
        int newlineIndex = sb.indexOf(NEWLINE, newLineReplacementBeginning);
        while (newlineIndex < sb.lastIndexOf(NEWLINE)) {
            sb.insert(newlineIndex, "\\\\");
            newlineIndex = sb.indexOf(NEWLINE, newlineIndex + 3);
        }
        
        sb.append("\\end{align}");
        return sb.toString();
    }
    
    /**
     * Prepares LaTeX display math environment.
     * @param input Text
     * @return Text prefixed with "\[" and ending with "\]".
     */
    public static String prepareDisplayMath(final String input) {
        String tmp = prepareBasicMath(input);
        tmp = replaceLast(tmp, NEWLINE, "");
        return new StringBuilder("\\[").append(tmp).append("\\]").append(NEWLINE).toString();
    }
    
    /**
     * Processes a LaTeX formula into image.
     * The image can be rendered or saved with ImageIO.
     * @param LaTeXInput Text formula in LaTeX syntax
     * @return Image containing typeset formula or null in case of error.
     */
    public static BufferedImage createLaTeXImage(final String LaTeXInput) {
        try {
            final TeXFormula formula = new TeXFormula(LaTeXInput);
            final TeXIcon icon = formula.createTeXIcon(TeXConstants.STYLE_DISPLAY, 20);
            icon.setInsets(new Insets(5, 5, 5, 5)); // Borders
            final int width = icon.getIconWidth();
            final int height = icon.getIconHeight();
            final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
            
            final Graphics2D graphics = image.createGraphics();
            graphics.setColor(Color.white);
            graphics.fillRect(0, 0, width, height);
            final JLabel jLabel = new JLabel();
            jLabel.setForeground(new Color(0, 0, 0));
            icon.paintIcon(jLabel, graphics, 0, 0);
            return image;
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            return null;
        }
    }
    
    /**
     * Writes .tex file with mathematical problem and its solution on disk, then
     * runs pdfLaTeX on the written file and opens corresponding .pdf automatically.
     * 
     * @param pdfLaTeX Executable pdfLaTeX binary or null for default TeX installation
     * @param workingDir Directory to write into
     * @param problem Mathematical problem in LaTeX syntax
     * @param solution Solution to the problem in LaTeX syntax
     * @param mainFrame Program GUI window for error messages
     */
    public static void exportPDF(final File pdfLaTeX, final File workingDir,
            final String problem, final String solution, final MainFrame mainFrame) {
        
        final java.util.Date date = new java.util.Date();
        final String timestamp = new java.sql.Timestamp(date.getTime()).toString();
        
        final StringBuilder fileName = new StringBuilder(workingDir.getAbsolutePath());
        fileName.append(File.separator).append("priklad ");
        fileName.append(timestamp.replaceAll(":", "-")).append(".tex");
        final File texFile = new File(fileName.toString());
        writeTeXFile(texFile, problem, solution);
        
        final String errorMsgHeader = "Chyba při exportu do PDF";
        final String errorMsg = "Překlad PDFLaTeXem zlyhal. Soubor: ";
        final String pathToPDFLaTeXFile = Config.getPDFLaTeXFile().getAbsolutePath();
        try {
            final JLRGenerator pdfGenerator = new JLRGenerator();
            pdfGenerator.deleteTempFiles(false, true, true);
            if (pdfLaTeX == null) {
                if (pdfGenerator.generate(texFile, workingDir, workingDir))
                    JLROpener.open(pdfGenerator.getPDF());
            } else {
                if (pdfGenerator.generate(pdfLaTeX, 1, texFile, workingDir, workingDir)) 
                    JLROpener.open(pdfGenerator.getPDF());
            }
            
            if (!pdfGenerator.getErrorMessage().equals("No errors occurred!")) {
                UserInputChecker.error(mainFrame, errorMsg + pathToPDFLaTeXFile, errorMsgHeader);
                System.err.println(pdfGenerator.getErrorMessage());
            }
        } catch (IOException ex) {
            UserInputChecker.error(mainFrame, errorMsg + pathToPDFLaTeXFile, errorMsgHeader);
            System.err.println(ex.getMessage());
        }
    }
    
    private static void writeTeXFile(final File file, final String problem, final String solution) {
        BufferedWriter writer = null;
        try {
            writer = new BufferedWriter(new FileWriter(file));
            writer.write("\\documentclass[12pt,a4paper,oneside,leqno]{article}");
            writer.newLine();
            writer.write("\\usepackage[utf8]{inputenc}");
            writer.newLine();
            writer.write("\\usepackage[czech]{babel}");
            writer.newLine();
            writer.write("\\usepackage[T1]{fontenc}");
            writer.newLine();
            writer.write("\\usepackage{amsmath}");
            writer.newLine();
            writer.write("\\usepackage{amsfonts}");
            writer.newLine();
            writer.write("\\usepackage{amssymb}");
            writer.newLine();
            writer.write("\\usepackage{xcolor}");
            writer.newLine();
            writer.write("\\begin{document}");
            writer.newLine();
            writer.write("\\noindent Zad\\'an\\'i:");
            writer.newLine();
            writer.write(prepareUnicodeForLaTeX(problem.replaceAll("align", "align*")));
            writer.newLine();
            writer.write("\\vfill");
            writer.newLine();
            writer.write("\\noindent \\v{R}e\\v{s}en\\'i:");
            writer.newLine();
            writer.write(prepareUnicodeForLaTeX(solution));
            writer.newLine();
            writer.write("\\end{document}");
        } catch(IOException ex) {
            System.err.println(ex.getMessage());
        } finally {
            try {
                if (writer != null)
                    writer.close();
            } catch (IOException ex) {
                System.err.println(ex.getMessage());
            }
        }
    }
    
    private static String prepareUnicodeForLaTeX(final String input) {
        String result = input.replaceAll("á", "\\\\'a");
        result = result.replaceAll("é", "\\\\'e");
        result = result.replaceAll("í", "\\\\'i");
        result = result.replaceAll("ó", "\\\\'o");
        result = result.replaceAll("ú", "\\\\'u");
        result = result.replaceAll("ý", "\\\\'y");
        return result;
    }
    
    /**
     * Replaces last occurrence of a substring in a string with given replacement.
     * @param string Input string
     * @param substring Substring to be replaced
     * @param replacement Replacement of the substring
     * @return String with replacement made or original string if it does not contain substring
     */
    public static String replaceLast(final String string, final String substring, final String replacement) {
        final int index = string.lastIndexOf(substring);
        if (index == -1)
            return string;
        
        StringBuilder sb = new StringBuilder(string.substring(0, index)).append(replacement);
        sb.append(string.substring(index + substring.length()));
        return sb.toString();
    }

    public static Integer[] buildIntegerArray(final List<Integer> integers) {
        return integers.toArray(new Integer[integers.size()]);
    }
}