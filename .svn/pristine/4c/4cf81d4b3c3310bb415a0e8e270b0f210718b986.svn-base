package Numbermat;

import java.util.ArrayList;
import java.util.List;

/**
 * Contains methods to generate step-by-step solutions to computations in Algorithms class.
 * 
 * @author Valdemar Svabensky <395868@mail.muni.cz>
 */
public final class AlgorithmsSteps {

    private AlgorithmsSteps() {
        throw new IllegalStateException("AlgorithmsSteps class should not be instantiated.");
    }
    
    public static final String SMALL_A_ACUTE = "\u00e1";
    public static final String SMALL_I_ACUTE = "\u00ed";
    
    public static final String SMALL_C_CARON = "\u010d";
    public static final String SMALL_E_CARON = "\u011b";
    public static final String SMALL_R_CARON = "\u0159";
    public static final String SMALL_S_CARON = "\u0161";
    
    public static final String CONG = " \u2261 ";           // " ≡ "
    public static final String XCONG = "x \u2261 ";         // "x ≡ "
    public static final String PHI = "\u03c6";              // "φ"
    public static final String PHIB = "\u03c6(";            // "φ("
    public static final String NOT_DIVIDES = " \u2224 ";    // "∤"

    /**
     * Euclidean algorithm for finding the greatest common divisor of two integers.
     * @param a Integer
     * @param b Integer
     * @return Step-by-step solution with every partial computation
     */
    public static String gcdSteps(int a, int b) {
        StringBuilder sb = new StringBuilder().append(buildGCDEquals(a, b));
        if (a < 0) {
            if (b < 0)
                return sb.append(buildGCDNewline(-a, -b)).append(gcdSteps(-a, -b)).toString();
            else
                return sb.append(buildGCDNewline(-a, b)).append(gcdSteps(-a, b)).toString();
        } else if (b < 0)
            return sb.append(buildGCDNewline(a, -b)).append(gcdSteps(a, -b)).toString();
        if (a < b)
            return sb.append(buildGCDNewline(b, a)).append(gcdSteps(b, a)).toString();
        
        StringBuilder result = new StringBuilder();
        while (b > 0) {
            int r = a % b;
            result.append(a).append(" = ");
            result.append(a / b).append(" * ");
            result.append(b).append(" + ");
            result.append(r).append(Utils.NEWLINE);
            a = b;
            b = r;
        }
        return result.append(sb).append(a).toString();
    }
    
    private static StringBuilder buildGCD(int a, int b) {
        return new StringBuilder().append("(").append(a).append(", ").append(b).append(")");
    }
    
    private static StringBuilder buildGCDEquals(int a, int b) {
        return buildGCD(a, b).append(" = ");
    }
    
    private static StringBuilder buildGCDNewline(int a, int b) {
        return buildGCD(a, b).append(Utils.NEWLINE);
    }

    /**
     * Extended Euclidean algorithm for solving Bezout's equality.
     * @param a Non-negative integer, a >= b
     * @param b Non-negative integer
     * @return Step-by-step solution with every partial computation
     */
    public static String bezoutSteps(int a, int b) {
        Algorithms.notSmallerThanCheck(a, b);
        Algorithms.notNegativeCheck(a, b);
        if (b == 0)
            return buildBezoutSolutionSimple(a, b, a, 1, 0).toString();
        
        List<Integer> gcdStepsList = new ArrayList<>();
        while (b > 0) {
            int r = a % b;
            gcdStepsList.add(a);
            gcdStepsList.add(a / b);
            gcdStepsList.add(b);
            gcdStepsList.add(r);
            a = b;
            b = r;
        }
        Integer[] gcdSteps = Utils.buildIntegerArray(gcdStepsList);
        if (gcdSteps.length == 4)
            return buildBezoutSolutionSimple(a, b, gcdSteps[2], 0, 1).toString();
        
        StringBuilder result = new StringBuilder();
        StringBuilder line = new StringBuilder();
        line.append(a).append(" = ");
        line.append(gcdSteps[gcdSteps.length - 8]).append(" - ");
        line.append(gcdSteps[gcdSteps.length - 7]).append(" * ");
        line.append(gcdSteps[gcdSteps.length - 6]).append(Utils.NEWLINE);
        result.append(line);
        boolean swapMinusSign = false; // minuses alternate every second iteration
        for (int i = gcdSteps.length - 9; i > -1; i = i - 4) {
            StringBuilder replacement = new StringBuilder();
            replacement.append("(").append(gcdSteps[i - 3]);
            replacement.append(" - ").append(gcdSteps[i - 2]);
            replacement.append(" * ").append(gcdSteps[i - 1]).append(")");
            int replaceIndex = line.lastIndexOf((gcdSteps[i]).toString());
            line.replace(replaceIndex, replaceIndex + replacement.length(), replacement.toString());
            result.append(line).append(Utils.NEWLINE);
            line = new StringBuilder();
            gcdSteps[i - 2] *= gcdSteps[i + 2];
            if (i == gcdSteps.length - 9) {
                gcdSteps[i - 2] += 1;
            } else {
                gcdSteps[i - 2] += gcdSteps[i + 6];
            }
            line.append(a).append(" = ");
            if (swapMinusSign) {
                line.append(gcdSteps[i + 2]);
            } else {
                line.append(gcdSteps[i + 2] * (-1));
            }
            line.append(" * ").append(gcdSteps[i - 3]);
            if (swapMinusSign) {
                line.append(" - ");
                swapMinusSign = false;
            } else {
                line.append(" + ");
                swapMinusSign = true;
            }
            line.append(gcdSteps[i - 2]).append(" * ");
            line.append(gcdSteps[i - 1]).append(Utils.NEWLINE);
            result.append(line);
        }
        result.append("x = ");
        if (swapMinusSign) {
            result.append(gcdSteps[5] * (-1));
        } else {
            if (gcdSteps.length == 8) {
                result.append(gcdSteps[6]);
            } else {
                result.append(gcdSteps[5]);
            }
        }
        result.append(", y = ");
        if (swapMinusSign) {
            result.append(gcdSteps[1]);
        } else {
            result.append(gcdSteps[1] * (-1));
        }
        return result.toString();
    }
    
    private static StringBuilder buildBezoutSolutionSimple(int a, int b, int d, int x, int y) {
        StringBuilder result = new StringBuilder();
        result.append(d).append(" = ").append(x).append(" * ").append(a).append(" + ");
        result.append(y).append(" * ").append(b).append(Utils.NEWLINE);
        result.append("x = ").append(x).append(", y = ").append(y).append(Utils.NEWLINE);
        return result;
    }
    
    public static String factorizeSteps(int n) {
        List<Pair<Integer, Integer>> factors = Algorithms.factorize(n);
        StringBuilder result = new StringBuilder().append(n).append(" = ");
        for (int i = 0; i < factors.size(); ++i) {
            int prime = factors.get(i).getFirst();
            int exponent = factors.get(i).getSecond();
            result.append(buildPower(prime, exponent));
            if (i < factors.size() - 1)
                result.append(" * ");
        }
        return result.toString();
    }
    
    private static StringBuilder buildPower(int base, int exp) {
        StringBuilder sb = new StringBuilder().append(base).append("^");
        if (exp > 9) sb.append("{");
        sb.append(exp);
        if (exp > 9) sb.append("}");
        return sb;
    }
    
    private static StringBuilder buildPhi(int n) {
        return new StringBuilder().append(PHIB).append(n).append(")"); // \u03c6 == phi
    }
    
    private static StringBuilder buildPhiEquals(int n) {
        return buildPhi(n).append(" = ");
    }
    
    private static StringBuilder buildPhi(String s) {
        return new StringBuilder().append(PHIB).append(s).append(")").append(Utils.NEWLINE);
    }
    
    public static String eulerPhiSteps(int n) {
        Algorithms.notNegativeCheck(n);
        if (n < 2)
            return buildPhiEquals(n).append(n).toString();
        
        String factorization = factorizeSteps(n);
        StringBuilder result = new StringBuilder().append(factorization).append(Utils.NEWLINE);
        factorization = factorization.replaceFirst(n + " = ", "");
        result.append(buildPhiEquals(n)).append(buildPhi(factorization));
        
        StringBuilder tmp = new StringBuilder(factorization.replaceAll(" \\* ", ") \\*" + PHIB));
        if (!tmp.toString().equals(factorization)) {
            result.append(buildPhiEquals(n)).append(buildPhi(tmp.toString()));
        }
        
        result.append(buildPhiEquals(n));
        int phi = 1;
        List<Pair<Integer, Integer>> factors = Algorithms.factorize(n);
        for (int i = 0; i < factors.size(); ++i) {
            int prime = factors.get(i).getFirst();
            int exponent = factors.get(i).getSecond();
            phi *= prime - 1;
            phi *= Math.pow(prime, exponent - 1);
            result.append("(").append(prime - 1).append(" * ");
            result.append(buildPower(prime, exponent - 1)).append(")");
            if (i < factors.size() - 1)
                result.append(" * ");
        }
        result.append(Utils.NEWLINE);
        result.append(buildPhiEquals(n));
        for (int i = 0; i < factors.size(); ++i) {
            int prime = factors.get(i).getFirst();
            int exponent = factors.get(i).getSecond();
            result.append((prime - 1) * (int)(Math.pow(prime, exponent - 1)));
            if (i < factors.size() - 1)
                result.append(" * ");
        }
        result.append(Utils.NEWLINE);
        if (factors.size() > 1) {
            result.append(buildPhiEquals(n)).append(phi).append(Utils.NEWLINE);
        }
        return result.toString();
    }
    
    private static StringBuilder buildModLineEnd(int m) {
        return new StringBuilder().append(" (mod ").append(m).append(")").append(Utils.NEWLINE);
    }
    
    private static StringBuilder congruenceHasNoSolution() {
        return new StringBuilder().append("Kongruence nemá řešení.").append(Utils.NEWLINE);
    }
    
    private static StringBuilder congruenceHasInfiniteSolutions() {
        return new StringBuilder().append("Kongruence má nekonečně mnoho řešení.").append(Utils.NEWLINE);
    }
    
    /**
     * Helper method for linearCongruenceSystemSteps for steps of single equation.
     * @param a Integer
     * @param b Integer
     * @param n Positive integer
     * @param repeatProblem
     * @return Step-by-step solution with every partial computation for a single congruence.
     */
    private static String linearCongruenceSteps(int a, int b, int n, boolean repeatProblem) {
        final StringBuilder lineEnd = buildModLineEnd(n);
        StringBuilder result = new StringBuilder();
        if (repeatProblem) {
            result.append((a != 1) ? a : "").append(XCONG).append(b).append(lineEnd);
        }
        int copyA = a;
        int copyB = b;
        a = Algorithms.normalizeIntModulo(a, n);
        b = Algorithms.normalizeIntModulo(b, n);
        if ((copyA != a) || (copyB != b)) {
            result.append((a != 1) ? a : "").append(XCONG).append(b).append(lineEnd);
        }
        if ((a == 0) && (b == 0)) {
            return result.append(congruenceHasInfiniteSolutions()).toString();
        }
        int numberOfSolutions = Algorithms.gcd(a, n);
        result.append("(").append(a).append(", ").append(n).append(") = ");
        result.append(numberOfSolutions);
        if (b % numberOfSolutions != 0) {
            result.append(NOT_DIVIDES).append(b).append(Utils.NEWLINE);
            return result.append(congruenceHasNoSolution()).toString();
        }
        result.append(" | ").append(b).append(Utils.NEWLINE);
        result.append(numberOfSolutions).append(" = ").append(a);
        result.append("r + ").append(n).append("s").append(Utils.NEWLINE);
        int bezoutCoefficientA; // coeffient r such that ra + sn = gcd(a, n)
        if (a > n) {
            bezoutCoefficientA = Algorithms.bezout(a, n).get(1);
        } else {
            bezoutCoefficientA = Algorithms.bezout(n, a).get(2);
        }
        int shiftedModulus = n / numberOfSolutions;
        int x = (bezoutCoefficientA * b) / numberOfSolutions;
        x = Algorithms.normalizeIntModulo(x, shiftedModulus);
        result.append("r = ").append(bezoutCoefficientA).append(Utils.NEWLINE);
        result.append(XCONG).append(b).append("r / ").append(numberOfSolutions).append(buildModLineEnd(shiftedModulus));
        result.append(XCONG).append(x).append(buildModLineEnd(shiftedModulus));
        return result.toString();
    }
    
    /*
     * Jednotlive podkroky riesnia preskocit
     * Pridat lin. cong. bezout
     */
    public static String linearCongruenceSystemSteps(int count, List<Integer> aList, List<Integer> bList, List<Integer> nList) {
        if (aList.size() != count) {
            throw new IllegalArgumentException("Invalid number of coefficients in aList");
        }
        if (bList.size() != count) {
            throw new IllegalArgumentException("Invalid number of coefficients in bList");
        }
        if (nList.size() != count) {
            throw new IllegalArgumentException("Invalid number of coefficients in nList");
        }
        StringBuilder result = new StringBuilder();
        List<StringBuilder> lineEnds = new ArrayList<>(count);
        final StringBuilder separator = new StringBuilder("--------------------").append(Utils.NEWLINE);
        boolean coefficentsModded = false;
        for (int i = 0; i < count; ++i) {
            int ai = aList.get(i);
            int bi = bList.get(i);
            int ni = nList.get(i);
            Algorithms.notZeroCheck(ni);
            Algorithms.notNegativeCheck(ni);
            aList.set(i, Algorithms.normalizeIntModulo(ai, ni));
            bList.set(i, Algorithms.normalizeIntModulo(bi, ni));
            if ((aList.get(i) != ai) || (bList.get(i) != bi)) {
                coefficentsModded = true;
            }
            lineEnds.add(buildModLineEnd(ni));
            result.append((ai != 1) ? ai : "").append(XCONG).append(bi).append(lineEnds.get(i));
        }
        result.append(separator);
        if (coefficentsModded) {
            for (int i = 0; i < count; ++i) {
                int ai = aList.get(i);
                result.append((ai != 1) ? ai : "").append(XCONG).append(bList.get(i)).append(lineEnds.get(i));
            }
            result.append(separator);
        }
        Pair<Integer, Integer> solution = new Pair();
        for (int i = 0; i < count; ++i) {
            Pair<Integer, Integer> partial = Algorithms.linearCongruence(aList.get(i), bList.get(i), nList.get(i));
            String partialSteps = linearCongruenceSteps(aList.get(i), bList.get(i), nList.get(i), count > 1);
            if (i > 0) {
                partialSteps = partialSteps.replaceAll("x", String.valueOf((char) (106 + i)));
            }
            if (count > 1) {
                partialSteps = partialSteps.substring(partialSteps.lastIndexOf(Utils.NEWLINE));
            }
            result.append(partialSteps);
            if (partial.equals(new Pair())) {
                return result.toString();
            }
            if (partial.equals(new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE))) {
                if ((solution.equals(new Pair())) && (i == count - 1) && (count != 1)) {
                    return result.append(separator).append(congruenceHasInfiniteSolutions()).toString();
                } else {
                    result.append(separator);
                    continue;
                }
            }
            if (solution.equals(new Pair())) {
                solution.setFirst(partial.getFirst());
                solution.setSecond(partial.getSecond());
            } else {
                solution.setFirst(solution.getFirst() + solution.getSecond() * partial.getFirst());
                solution.setSecond(solution.getSecond() * partial.getSecond());
                result.append((char) (106 + i)).append(" = ").append(partial.getFirst()).append(" + ");
                result.append(partial.getSecond()).append((char) (107 + i)).append(Utils.NEWLINE);
            }
            if (count > 1) {
                result.append("x = ").append(solution.getFirst()).append(" + ");
                result.append(solution.getSecond()).append((char) (107 + i)).append(Utils.NEWLINE);
            }
            if (i < count - 1) {
                bList.set(i + 1, bList.get(i + 1) - (aList.get(i + 1) * solution.getFirst()));
                aList.set(i + 1, aList.get(i + 1) * solution.getSecond());
                result.append(separator);
            }
        }
        if (count > 1) {
            result.append(XCONG).append(solution.getFirst()).append(buildModLineEnd(solution.getSecond()));
        }
        return result.toString();
    }

    public static String elementsOfUnitGroupSteps(int n) {
        Algorithms.notSmallerThanCheck(n, 2);
        StringBuilder result = new StringBuilder().append("Z").append(n).append("\u00d7 = ");
        if (Algorithms.isPrime(n)) {
            result.append("Z").append(n).append("*").append(Utils.NEWLINE);
            return result.toString();
        }
        result.append("\\{");
        for (int i = 1; i < n; ++i) {
            if (Algorithms.isCoprime(i, n)) {
                result.append(i);
                if (i < n - 1) {
                    result.append(", ");
                }
            }
        }
        result.append("\\}").append(Utils.NEWLINE);
        return result.toString();
    }
    
    public static String unitGroupElementOrderSteps(int element, int n) {
        Algorithms.notSmallerThanCheck(element, 1);
        Algorithms.notSmallerThanCheck(n, 2);
        int elementOrder = Algorithms.unitGroupElementOrder(element, n);
        int groupOrder = Algorithms.eulerPhi(n);
        List<Integer> groupOrderDivisors = Algorithms.divisors(groupOrder);
        StringBuilder result = new StringBuilder(AlgorithmsSteps.elementsOfUnitGroupSteps(n));
        result.append("\u0158\u00e1d grupy: \u03c6(").append(n).append(") = ").append(groupOrder).append(Utils.NEWLINE);
        result.append("Mo\u017en\u00e9 \u0159\u00e1dy prvk\u016f: ").append(groupOrderDivisors).append(Utils.NEWLINE);
        result = new StringBuilder(result.toString().replaceAll("\\[", "\\\\{"));
        result = new StringBuilder(result.toString().replaceAll("\\]", "\\\\}"));
        
        final StringBuilder lineEnd = new StringBuilder("1 ").append(buildModLineEnd(n));
        for (int i = 0; i < groupOrderDivisors.size(); ++i) {
            int currentDivisor = groupOrderDivisors.get(i);
            if (currentDivisor == elementOrder)
                break;
            result.append(buildPower(element, currentDivisor)).append(" \u2262 ").append(lineEnd);
        }
        result.append(buildPower(element, elementOrder)).append(CONG).append(lineEnd);
        result.append("\u0158\u00e1d prvku ").append(element).append(": ").append(elementOrder).append(Utils.NEWLINE);
        return result.toString();
    }
    
    public static String modPowSteps(int base, int exp, int mod) {
        Algorithms.notNegativeCheck(exp);
        Algorithms.notSmallerThanCheck(mod, 2);
        StringBuilder lineStart = buildPower(base, exp).append(CONG);
        final StringBuilder lineEnd = new StringBuilder(" (mod ").append(mod).append(")").append(Utils.NEWLINE);
        if (base == 0) {
            if (exp == 0) {
                return buildModPowResult(1, lineStart, lineEnd).toString();
            } else {
                return buildModPowResult(0, lineStart, lineEnd).toString();
            }
        }
        if (base == 1) {
            return buildModPowResult(1, lineStart, lineEnd).toString();
        }
        if (base == -1) {
            return (exp % 2 == 0 ? buildModPowResult(1, lineStart, lineEnd) : buildModPowResult(-1 + mod, lineStart, lineEnd)).toString();
        }
        StringBuilder result = new StringBuilder();
        int baseCopy = base;
        base = Algorithms.normalizeIntModulo(base, mod);
        if (base != baseCopy) {
            result.append(lineStart);
            result.append(buildPower(base, exp)).append(lineEnd);
            lineStart = buildPower(base, exp).append(CONG);
        }
        if (Algorithms.isCoprime(base, mod)) {
            int phi = Algorithms.eulerPhi(mod);
            int expCopy = exp;
            exp = Algorithms.normalizeIntModulo(exp, phi);
            if (exp != expCopy) {
                result.append(PHIB).append(mod).append(") = ").append(phi).append(Utils.NEWLINE);
                if (exp == 0) {
                    return result.append(buildModPowResult(1, lineStart, lineEnd)).toString();
                }
                result.append(lineStart).append(buildPower(base, exp)).append(lineEnd);
                lineStart = buildPower(base, exp).append(CONG);
            }
        }
        try {
            int order = Algorithms.unitGroupElementOrder(base, mod);
            int expCopy = exp;
            exp = Algorithms.normalizeIntModulo(exp, order);
            if (exp != expCopy) {
                result.append(buildPower(base, order)).append(CONG).append("1 ").append(lineEnd);
                if (exp == 0) {
                    return result.append(buildModPowResult(1, lineStart, lineEnd)).toString();
                }
                result.append(lineStart).append(buildPower(base, exp)).append(lineEnd);
                lineStart = buildPower(base, exp).append(CONG);
            }
        } catch (IllegalArgumentException ex) {
        }
        result.append(lineStart);
        if ((mod > 7) && (base - mod > -4)) {
            result.append(buildPower(base - mod, exp)).append(lineEnd);
            lineStart = buildPower(base - mod, exp).append(CONG);
            result.append(lineStart);
        }
        result.append(Algorithms.modPow(base, exp, mod)).append(lineEnd);
        return result.toString();
    }
    
    private static StringBuilder buildModPowResult(int result, StringBuilder lineStart, StringBuilder lineEnd) {
        return new StringBuilder().append(lineStart).append(result).append(lineEnd);
    }
}
