package Numbermat;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.junit.*;
import static org.junit.Assert.*;

/**
 *
 * @author Valdemar Svabensky <395868@mail.muni.cz>
 */
public class AlgorithmsTests {
    
    int[] primes = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 97};
    
    @Test
    public void testIsPrime() {
        int[] bigPrimes = new int[] {101424101, 1500450271, 179858971, 181666181, 189464981, 193414391,
            194000491, 198565891, 199909991, 199999991};
        int[] nonPrimes = new int[] {0, 1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 341, 1234567890};
        
        for (int i = 0; i < primes.length; ++i)
            assertTrue(Algorithms.isPrime(primes[i]));
        for (int i = 0; i < bigPrimes.length; ++i)
            assertTrue(Algorithms.isPrime(bigPrimes[i]));
        for (int i = 0; i < nonPrimes.length; ++i)
            assertFalse(Algorithms.isPrime(nonPrimes[i]));
        for (int i = -1; i > -11; --i)
            assertFalse(Algorithms.isPrime(i));
    }
    
    @Test
    public void testIsCoprime() {
        assertTrue(Algorithms.isCoprime(1, 3458));
        assertTrue(Algorithms.isCoprime(1, 0));
        assertTrue(Algorithms.isCoprime(3, 2));
        assertTrue(Algorithms.isCoprime(-1, 1));
        
        assertFalse(Algorithms.isCoprime(0, 0));
        assertFalse(Algorithms.isCoprime(4864, 3458));
        assertFalse(Algorithms.isCoprime(13, 169));
        assertFalse(Algorithms.isCoprime(-8, -16));
    }
    
    @Test
    public void testDivisors() {
        List<Integer> result, expected;
        
        result = Algorithms.divisors(2);
        expected = Arrays.asList(1, 2);
        assertTrue(result.equals(expected));
        
        result = Algorithms.divisors(28);
        expected = Arrays.asList(1, 2, 4, 7, 14, 28);
        assertTrue(result.equals(expected));
        
        result = Algorithms.divisors(-28);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testDivisorsFail() {
        try {
            Algorithms.divisors(0);
            fail();
        } catch (IllegalArgumentException ex) {
            //OK
        }
    }
    
    @Test
    public void testIsPowerOfTwo() {
        int[] nonPowers = new int[] {-8, -4, -2, -1, 0, 3, 5, 6, 7, 9, 10, 11, 1022};
        for (int i = 1; i < Algorithms.FOR_LOOP_ATTEMPTS; i = 2*i)
            assertTrue(Algorithms.isPowerOf2(i));
        for (int i = 0; i < nonPowers.length; ++i)
            assertFalse(Algorithms.isPowerOf2(nonPowers[i]));
    }
    
    @Test
    public void testGetNumberOfBits() {
        assertTrue(Algorithms.getNumberOfBits(0) == 1);
        
        int expectedNumberOfBits = 0;
        for (int i = 1; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            if (Algorithms.isPowerOf2(i))
                expectedNumberOfBits++;
            
            assertTrue(Algorithms.getNumberOfBits(i) == expectedNumberOfBits);
            assertTrue(Algorithms.getNumberOfBits(-i) == expectedNumberOfBits + 1);
        }
    }
    
    @Test
    public void testRandInt() {
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            int p = Algorithms.randInt(1, 9999);
            assertTrue((p > 0) && (p < 10000));
        }
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            int p = Algorithms.randInt(-9999, -1);
            assertTrue((p < 0) && (p > -10000));
        }
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            int p = Algorithms.randInt(0, 0);
            assertTrue(p == 0);
        }
    }
    
    @Test
    public void testRandIntFail() {
        try {
            Algorithms.randInt(0, 0, false);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {    
            Algorithms.randInt(1, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try { 
            Algorithms.randInt(-4, -10);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testRandPrime() {
        assertTrue(Algorithms.randPrime(0, 2) == 2);
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            int p = Algorithms.randPrime(0, 10000);
            assertTrue(Algorithms.isPrime(p));
        }
    }
    
    @Test
    public void testRandPrimeFail() {
        try {
            Algorithms.randPrime(10, 0);    // Max bound is smaller than min
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.randPrime(-1, 10);   // Min bound is negative
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.randPrime(0, 0);     // Max bound is smaller than 2
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.randPrime(4, 4);     // No primes exist here
            fail();
        } catch (RuntimeException ex) {}
        try {
            Algorithms.randPrime(954, 966); // And here
            fail();
        } catch (RuntimeException ex) {}
    }
    
    @Test
    public void testRandCoprime() {
        assertTrue(Algorithms.randCoprime(1, 1).equals(new Pair(1, 1)));
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            Pair<Integer, Integer> coprimes = Algorithms.randCoprime(1, 500);
            assertTrue(Algorithms.isCoprime(coprimes.getFirst(), coprimes.getSecond()));
        }
    }
    
    @Test
    public void testRandCoprimeFail() {
        try {
            Algorithms.randCoprime(10, 0);    // Max bound is smaller than min
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.randCoprime(-1, 10);   // Min bound is negative
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.randCoprime(8, 8);     // No coprimes exist here
            fail();
        } catch (RuntimeException ex) {}
    }
    
    @Test
    public void testGCD() {
        allPossibleGCDs(113, 50, 1);
        allPossibleGCDs(4864, 3458, 38);
        allPossibleGCDs(10175, 2277, 11);
        allPossibleGCDs(-15, -10, 5);
        allPossibleGCDs(1, 144, 1);
        allPossibleGCDs(1, 0, 1);
        allPossibleGCDs(0, 0, 0);
    }
    
    private void allPossibleGCDs(int a, int b, int gcd) {
        assertTrue(Algorithms.gcd(a, b) == gcd);
        assertTrue(Algorithms.gcd(-a, b) == gcd);
        assertTrue(Algorithms.gcd(a, -b) == gcd);
        assertTrue(Algorithms.gcd(-a, -b) == gcd);
        assertTrue(Algorithms.gcd(b, a) == gcd);
        assertTrue(Algorithms.gcd(-b, a) == gcd);
        assertTrue(Algorithms.gcd(b, -a) == gcd);
        assertTrue(Algorithms.gcd(-b, -a) == gcd);
    }
    
    @Test
    public void testBezout() {
        // 98 * (-1) + 21 * 5 = 7
        testBezoutHelper(98, -1, 21, 5, 7);
        testBezoutHelper(4864, 32, 3458, -45, 38);
        testBezoutHelper(15, 0, 1, 1, 1);
        testBezoutHelper(15, 1, 0, 0, 15);
        testBezoutHelper(0, 1, 0, 0, 0);
    }
    
    // ax + by = gcd;
    private void testBezoutHelper(int a, int x, int b, int y, int gcd) {
        List<Integer> result = Algorithms.bezout(a, b);
        List<Integer> expected = Arrays.asList(gcd, x, y);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testBezoutFail() {
        try {
            Algorithms.bezout(15, -15);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.bezout(4, 15);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testFactorize() {
        int n = 4864;
        ArrayList<Pair<Integer, Integer>> factors = new ArrayList<>();
        factors.add(new Pair(2, 8));
        factors.add(new Pair(19, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 3458;
        factors = new ArrayList<>();
        factors.add(new Pair(2, 1));
        factors.add(new Pair(7, 1));
        factors.add(new Pair(13, 1));
        factors.add(new Pair(19, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 1;
        factors = new ArrayList<>();
        factors.add(new Pair(1, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 0;
        factors = new ArrayList<>();
        factors.add(new Pair(0, 1));
        assertEquals(factors, Algorithms.factorize(n));
    }
    
    @Test
    public void testFactorizeFail() {
        try {
            Algorithms.factorize(-15);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testEulerPhi() {
        assertTrue(Algorithms.eulerPhi(0) == 0);
        assertTrue(Algorithms.eulerPhi(1) == 1);
        assertTrue(Algorithms.eulerPhi(25) == 20);
        assertTrue(Algorithms.eulerPhi(33) == 20);
        assertTrue(Algorithms.eulerPhi(44) == 20);
        assertTrue(Algorithms.eulerPhi(50) == 20);
        assertTrue(Algorithms.eulerPhi(66) == 20);
        assertTrue(Algorithms.eulerPhi(735) == 336);
        assertTrue(Algorithms.eulerPhi(1212) == 400);
        assertTrue(Algorithms.eulerPhi(2010) == 528);
        assertTrue(Algorithms.eulerPhi(3458) == 1296);
        assertTrue(Algorithms.eulerPhi(4864) == 2304);
    }
    
    @Test
    public void testEulerPhiFail() {
        try {
            Algorithms.eulerPhi(-5);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testLinearCongruence() {
        Pair<Integer, Integer> result;
        Pair<Integer, Integer> expected;
        
        result = Algorithms.linearCongruence(3, 5, 17);
        expected = new Pair(13, 17);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(12, 20, 28);
        expected = new Pair(4, 7);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(21, 6, 9);
        expected = new Pair(2, 3);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(11881376, 16, 11);
        expected = new Pair(5, 11);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(26, 4, 9);
        expected = new Pair(5, 9);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(76, 8, 10);
        expected = new Pair(3, 5);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(5, 7, 8);
        expected = new Pair(3, 8);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(16, 4, 6);
        expected = new Pair(1, 3);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(4, 3, 7);
        expected = new Pair(6, 7);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(642, 1844, 1144);
        expected = new Pair(10, 572);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(3, 1, 6);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(5, 4, 5);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(5, 0, 5);
        expected = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);
        assertTrue(result.equals(expected));
        
        result = Algorithms.linearCongruence(0, 3, 3);
        expected = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testLinearCongruenceFail() {
        try {
            Algorithms.linearCongruence(12, 20, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.linearCongruence(12, 5, -14);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testLinearCongruenceSystem() {
        List<Integer> aList;
        List<Integer> bList;
        List<Integer> nList;
        Pair<Integer, Integer> result;
        Pair<Integer, Integer> expected;
        
        /* 2x = 2 (mod 6)
           3x = 2 (mod 7)
           2x = 4 (mod 8) */
        aList = new ArrayList<>(Arrays.asList(2, 3, 2));
        bList = new ArrayList<>(Arrays.asList(2, 2, 4));
        nList = new ArrayList<>(Arrays.asList(6, 7, 8));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(10, 84);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(-5, 2));
        nList = new ArrayList<>(Arrays.asList(20, 13));
        result = Algorithms.linearCongruenceSystem(2, aList, bList, nList);
        expected = new Pair(15, 260);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(8, 5, 1));
        nList = new ArrayList<>(Arrays.asList(11, 8, 3));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(85, 264);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(10, 3, 0));
        nList = new ArrayList<>(Arrays.asList(13, 12, 11));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(231, 1716);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(729, 169, 32));
        bList = new ArrayList<>(Arrays.asList(343, 27, 1331));
        nList = new ArrayList<>(Arrays.asList(5, 7, 9));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(97, 315);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(6, 2));
        nList = new ArrayList<>(Arrays.asList(8, 5));
        result = Algorithms.linearCongruenceSystem(2, aList, bList, nList);
        expected = new Pair(22, 40);
        assertTrue(result.equals(expected));        
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(2, 4, 6));
        nList = new ArrayList<>(Arrays.asList(4, 6, 10));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(46, 60);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(2, 3, 5));
        bList = new ArrayList<>(Arrays.asList(3, 5, 7));
        nList = new ArrayList<>(Arrays.asList(5, 7, 9));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(284, 315);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 2, 5));
        nList = new ArrayList<>(Arrays.asList(7, 11, 13));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(486, 1001);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 1, -3));
        nList = new ArrayList<>(Arrays.asList(6, 5, 7));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(81, 210);
        assertTrue(result.equals(expected));
        
        /* Unsolvable */
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 7));
        nList = new ArrayList<>(Arrays.asList(9, 15));
        result = Algorithms.linearCongruenceSystem(2, aList, bList, nList);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(1, -1));
        nList = new ArrayList<>(Arrays.asList(3, 9));
        result = Algorithms.linearCongruenceSystem(2, aList, bList, nList);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(5));
        bList = new ArrayList<>(Arrays.asList(4));
        nList = new ArrayList<>(Arrays.asList(5));
        result = Algorithms.linearCongruenceSystem(1, aList, bList, nList);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        /* Infinite solutions */
        aList = new ArrayList<>(Arrays.asList(5));
        bList = new ArrayList<>(Arrays.asList(0));
        nList = new ArrayList<>(Arrays.asList(5));
        result = Algorithms.linearCongruenceSystem(1, aList, bList, nList);
        expected = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(0));
        bList = new ArrayList<>(Arrays.asList(3));
        nList = new ArrayList<>(Arrays.asList(3));
        result = Algorithms.linearCongruenceSystem(1, aList, bList, nList);
        expected = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(0, 7, 158));
        bList = new ArrayList<>(Arrays.asList(3, 14, 0));
        nList = new ArrayList<>(Arrays.asList(3, 7, 158));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);
        assertTrue(result.equals(expected));
        
        /* Unsolvable, but containting equation with infinite solutions */
        aList = new ArrayList<>(Arrays.asList(7, 158, 16));
        bList = new ArrayList<>(Arrays.asList(14, 0, 5));
        nList = new ArrayList<>(Arrays.asList(7, 158, 8));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair();
        assertTrue(result.equals(expected));
        
        /* Solvable, but containting equation with infinite solutions */
        aList = new ArrayList<>(Arrays.asList(2, 1, 40));
        bList = new ArrayList<>(Arrays.asList(3, 4, 40));
        nList = new ArrayList<>(Arrays.asList(5, 5, 20));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(4, 5);
        assertTrue(result.equals(expected));
        
        aList = new ArrayList<>(Arrays.asList(40, 2, 1));
        bList = new ArrayList<>(Arrays.asList(40, 3, 4));
        nList = new ArrayList<>(Arrays.asList(20, 5, 5));
        result = Algorithms.linearCongruenceSystem(3, aList, bList, nList);
        expected = new Pair(4, 5);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testLinearCongruenceSystemFail() {
        List<Integer> aList = new ArrayList<>(Arrays.asList(2, 3, 2));
        List<Integer> bList = new ArrayList<>(Arrays.asList(2, 2, 4));
        List<Integer> nList = new ArrayList<>(Arrays.asList(6, 7, 0));
        try {
            Algorithms.linearCongruenceSystem(3, aList, bList, nList);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testElementsOfUnitGroup() {
        List<Integer> result, expected;
        
        int n;
        for (int i = 0; i < primes.length; ++i) {
            n = primes[i];
            result = Algorithms.elementsOfUnitGroup(n);
            expected = new ArrayList<>();
            for (int j = 1; j < primes[i]; ++j)
                expected.add(j);
            assertTrue(result.equals(expected));
            assertTrue(result.size() == Algorithms.eulerPhi(n));
        }
        
        n = 4;
        result = Algorithms.elementsOfUnitGroup(n);
        expected = Arrays.asList(1, 3);
        assertTrue(result.equals(expected));
        assertTrue(result.size() == Algorithms.eulerPhi(n));
        
        n = 6;
        result = Algorithms.elementsOfUnitGroup(n);
        expected = Arrays.asList(1, 5);
        assertTrue(result.equals(expected));
        assertTrue(result.size() == Algorithms.eulerPhi(n));
        
        n = 8;
        result = Algorithms.elementsOfUnitGroup(8);
        expected = Arrays.asList(1, 3, 5, 7);
        assertTrue(result.equals(expected));
        assertTrue(result.size() == Algorithms.eulerPhi(n));

        
        n = 12;
        result = Algorithms.elementsOfUnitGroup(12);
        expected = Arrays.asList(1, 5, 7, 11);
        assertTrue(result.equals(expected));
        assertTrue(result.size() == Algorithms.eulerPhi(n));
    }
    
    @Test
    public void testElementsOfUnitGroupFail() {
        try {
            Algorithms.elementsOfUnitGroup(1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.elementsOfUnitGroup(0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.elementsOfUnitGroup(-1);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testUnitGroupElementOrder() {
        int n = 3; // group Z3×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 2);
        
        n = 4; // group Z4×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 2);
        
        n = 5; // group Z5×
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 4);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 4);
        assertTrue(Algorithms.unitGroupElementOrder(4, n) == 2);
        
        n = 6; // group Z6×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(5, n) == 2);
        
        n = 7; // group Z7×
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 3);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 6);
        assertTrue(Algorithms.unitGroupElementOrder(4, n) == 3);
        assertTrue(Algorithms.unitGroupElementOrder(5, n) == 6);
        assertTrue(Algorithms.unitGroupElementOrder(6, n) == 2);
        
        assertTrue(Algorithms.unitGroupElementOrder(86, 97) == 48);
    }
    
    @Test
    public void testUnitGroupElementOrderFail() {
        try {
            Algorithms.unitGroupElementOrder(1, 1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.unitGroupElementOrder(1, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.unitGroupElementOrder(1, -1);
            fail();
        } catch (IllegalArgumentException ex) {}
        
        try {
            Algorithms.unitGroupElementOrder(7, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.unitGroupElementOrder(0, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.unitGroupElementOrder(-4, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.unitGroupElementOrder(5, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testModPow() {
        assertTrue(Algorithms.modPow(0, 0, 1574) == 1);
        assertTrue(Algorithms.modPow(0, 275, 1411) == 0);
        assertTrue(Algorithms.modPow(1, 557, 11889) == 1);
        assertTrue(Algorithms.modPow(-1, 557, 11889) == 11888);
        assertTrue(Algorithms.modPow(-1, 558, 11889) == 1);
        assertTrue(Algorithms.modPow(2, 6, 63) == 1);
        assertTrue(Algorithms.modPow(14, 5, 11) == 1);
        assertTrue(Algorithms.modPow(7, 144, 52) == 1);
        assertTrue(Algorithms.modPow(3, 351, 1000) == 747);
        assertTrue(Algorithms.modPow(157, 248, 369) == 160);
        assertTrue(Algorithms.modPow(-47, 25, 100) == 93);
    }
    
    @Test
    public void testModPowFail() {
        try {
            Algorithms.modPow(14, -1, 15);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.modPow(14, 1, -15);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.modPow(14, 71, 1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.modPow(14, -4, -815);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testLegendreSymbol() {
        assertTrue(Algorithms.legendreSymbol(219, 383) == 1);
        assertTrue(Algorithms.legendreSymbol(79, 101) == 1);
        assertTrue(Algorithms.legendreSymbol(3, 59) == 1);
        assertTrue(Algorithms.legendreSymbol(49, 7) == 0);
        assertTrue(Algorithms.legendreSymbol(7, 43) == -1);
        assertTrue(Algorithms.legendreSymbol(-1, 3) == -1);
    }
    
    @Test
    public void testLegendreSymbolFail() {
        try {
            Algorithms.legendreSymbol(14, -1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.legendreSymbol(14, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.legendreSymbol(14, 1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.legendreSymbol(14, 2);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testQuadraticCongruenceSimple() {
        testQuadraticCongruenceSimpleMod1();
        testQuadraticCongruenceSimpleMod2();
        testQuadraticCongruenceSimpleMod3();
        testQuadraticCongruenceSimpleMod4();
        testQuadraticCongruenceSimpleMod5();
        testQuadraticCongruenceSimpleMod6();
        testQuadraticCongruenceSimpleMod7();
        testQuadraticCongruenceSimpleMod8();
        testQuadraticCongruenceSimpleMod9();
        testQuadraticCongruenceSimpleMod10();
        testQuadraticCongruenceSimpleMod11();
        testQuadraticCongruenceSimpleMod12();
        testQuadraticCongruenceSimpleMod16();
        testQuadraticCongruenceSimpleOther();
    }
    
    private void testQuadraticCongruenceSimpleMod1() {
        Set<Pair<Integer, Integer>> result, expected;
        result = Algorithms.quadraticCongruenceSimple(14, 1);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 1));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod2() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 2;
        
        // x^2 ≡ 14 (mod 2) => x ≡ 0 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(14, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m));
        assertTrue(result.equals(expected));
        
        // x^2 ≡ 1 (mod 2) => x = 1 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        assertTrue(result.equals(expected));
        // x^2 ≡ 7 (mod 2) => x = 1 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(7, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod3() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 3;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(15, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(2, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(7, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod4() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 4;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(16, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod5() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 5;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(15, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(4, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(101, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(3, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(54, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod6() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 6;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(66, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(5, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(37, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(3, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(39, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(4, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(604, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod7() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 7;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(2, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m));
        expected.add(new Pair<>(4, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(5, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod8() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 8;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod9() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 9;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 7));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(8, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(7, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(7, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(4, m));
        expected.add(new Pair<>(5, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod10() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 10;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 6, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(9, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(8, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(5, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(5, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(6, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(4, m));
        expected.add(new Pair<>(6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m));
        expected.add(new Pair<>(7, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod11() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 11;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4, 5, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m));
        expected.add(new Pair<>(10, m));
        assertTrue(result.equals(expected));
                
        result = Algorithms.quadraticCongruenceSimple(3, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(5, m));
        expected.add(new Pair<>(6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m));
        expected.add(new Pair<>(9, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(5, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(4, m));
        expected.add(new Pair<>(7, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m));
        expected.add(new Pair<>(8, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod12() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 12;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m/2));
        expected.add(new Pair<>(5, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m/2));
        expected.add(new Pair<>(4, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod16() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 16;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m/2));
        expected.add(new Pair<>(7, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m/2));
        expected.add(new Pair<>(5, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod32() {
        Set<Pair<Integer, Integer>> result, expected;
        int m = 32;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9, 16, 17, 25));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(1, m/2));
        expected.add(new Pair<>(15, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, m/8));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(3, m/2));
        expected.add(new Pair<>(13, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(16, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(4, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(17, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(7, m/2));
        expected.add(new Pair<>(9, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(25, m);
        expected = new HashSet<>();
        expected.add(new Pair<>(5, m/2));
        expected.add(new Pair<>(11, m/2));
        assertTrue(result.equals(expected));
    }
    
    // Test all non residues: numbers, for which x^2 ≡ i (mod m) does not have a solution
    private void testQuadraticCongruenceSimpleNonResidues(List<Integer> residues, int m) {
        Set<Pair<Integer, Integer>> result;
        Set<Pair<Integer, Integer>> expected = new HashSet<>();;
        for (int i = 2; i < m; ++i) {
            if (residues.contains(i))
                continue;
            result = Algorithms.quadraticCongruenceSimple(i, m);
            assertTrue(result.equals(expected));
        }
    }
    
    private void testQuadraticCongruenceSimpleNonEmptySolution(List<Integer> residues, int m) {
        Set<Pair<Integer, Integer>> result;
        Set<Pair<Integer, Integer>> empty = new HashSet<>();
        for (int i = 0; i < residues.size(); ++i) {
            result = Algorithms.quadraticCongruenceSimple(residues.get(i), m);
            assertTrue(!result.equals(empty));
        }
    }
    
    // Test non-residues from 13 up
    private void testQuadraticCongruenceSimpleOther() {
        int m = 13;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4, 9, 10, 12));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 14;
        residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4, 7, 8, 9, 11));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 15;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 6, 9, 10));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 17;
        residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4, 8, 9, 13, 15, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 18;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 7, 9, 10, 13, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 19;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 6, 7, 9, 11, 16, 17));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 20;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 9, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
    }
    
    @Test
    public void testQuadraticCongruenceSimpleFail() {
        try {
            Algorithms.quadraticCongruenceSimple(14, -1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceSimple(14, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testQuadraticCongruenceGeneral() {
        Set<Pair<Integer, Integer>> result, expected;
        
        // b == 0
        result = Algorithms.quadraticCongruenceGeneral(3, 0, 4, 2);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 2));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(7, 0, 5, 11);
        expected = new HashSet<>();
        expected.add(new Pair<>(2, 11));
        expected.add(new Pair<>(9, 11));
        assertTrue(result.equals(expected));
        
        // c == 0
        result = Algorithms.quadraticCongruenceGeneral(6, 2, 0, 5);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 5));
        expected.add(new Pair<>(3, 5));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(8, 4, 0, 17);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 17));
        expected.add(new Pair<>(8, 17));
        assertTrue(result.equals(expected));
        
        // b == 0, c == 0
        result = Algorithms.quadraticCongruenceGeneral(7, 0, 0, 16);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 16));
        expected.add(new Pair<>(4, 16));
        expected.add(new Pair<>(8, 16));
        expected.add(new Pair<>(12, 16));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(5, 0, 0, 17);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 17));
        assertTrue(result.equals(expected));
        
        // general
        result = Algorithms.quadraticCongruenceGeneral(3, 5, 4, 2);
        expected = new HashSet<>();
        expected.add(new Pair<>(0, 2));
        expected.add(new Pair<>(1, 2));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(5, 7, 9, 11);
        expected = new HashSet<>();
        expected.add(new Pair<>(6, 11));
        expected.add(new Pair<>(8, 11));
        assertTrue(result.equals(expected));
        
        // no solution
        result = Algorithms.quadraticCongruenceGeneral(8, 13, 17, 65);
        expected = new HashSet<>();
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(6, 8, 10, 13);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testQuadraticCongruenceGeneralFail() {
        try {
            Algorithms.quadraticCongruenceGeneral(0, 0, 0, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceGeneral(0, 0, 0, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceGeneral(16, 0, 0, 32);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testBinomialCongruence() {
        Set<Integer> result, expected;
        
        result = Algorithms.binomialCongruence(5, 534, 529);
        expected = new HashSet<>();
        expected.add(333);
        assertTrue(result.equals(expected));
    }
}