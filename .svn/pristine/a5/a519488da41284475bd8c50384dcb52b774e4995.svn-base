package Numbermat;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.junit.*;
import static org.junit.Assert.*;

/**
 *
 * @author Valdemar Svabensky <395868@mail.muni.cz>
 */
public class AlgorithmsTests {
    
    public static final int[] PRIMES = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 97};
    
    public static final List<Integer> EMPTY = new ArrayList<>();
    
    // Congruences:
    public static final Pair<Integer, Integer> NO_SOLUTIONS = new Pair<>();
    public static final Pair<Integer, Integer> INFINITE_SOLUTIONS = new Pair<>(0, 1);
    
    @Test
    public void testIsPrime() {
        final int[] bigPrimes = new int[] {101424101, 1500450271, 179858971, 181666181, 189464981, 193414391,
            194000491, 198565891, 199909991, 199999991};
        final int[] nonPrimes = new int[] {0, 1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 341, 1234567890};
        
        for (int i = 0; i < PRIMES.length; ++i)
            assertTrue(Algorithms.isPrime(PRIMES[i]));
        for (int i = 0; i < bigPrimes.length; ++i)
            assertTrue(Algorithms.isPrime(bigPrimes[i]));
        for (int i = 0; i < nonPrimes.length; ++i)
            assertFalse(Algorithms.isPrime(nonPrimes[i]));
        for (int i = -1; i > -11; --i)
            assertFalse(Algorithms.isPrime(i));
    }
    
    @Test
    public void testIsCoprime() {
        assertTrue(Algorithms.isCoprime(1, 3458));
        assertTrue(Algorithms.isCoprime(1, 0));
        assertTrue(Algorithms.isCoprime(3, 2));
        assertTrue(Algorithms.isCoprime(-1, 1));
        
        assertFalse(Algorithms.isCoprime(0, 0));
        assertFalse(Algorithms.isCoprime(4864, 3458));
        assertFalse(Algorithms.isCoprime(13, 169));
        assertFalse(Algorithms.isCoprime(-8, -16));
    }
    
    @Test
    public void testDivisors() {
        testDivisors(1, Arrays.asList(1));
        testDivisors(2, Arrays.asList(1, 2));
        testDivisors(5, Arrays.asList(1, 5));
        testDivisors(28, Arrays.asList(1, 2, 4, 7, 14, 28));
        testDivisors(-28, Arrays.asList(1, 2, 4, 7, 14, 28));
        testDivisors(744, Arrays.asList(1, 2, 3, 4, 6, 8, 12, 24, 31, 62, 93, 124, 186, 248, 372, 744));
    }
    
    private void testDivisors(final int n, final List<Integer> expected) {
        assertEquals(Algorithms.divisors(n), expected);
    }
    
    @Test
    public void testDivisorsFail() {
        try {
            Algorithms.divisors(0);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testIsPowerOf2() {
        final int[] nonPowers = new int[] {-8, -4, -2, -1, 0, 3, 5, 6, 7, 9, 10, 11, 1022};
        for (int i = 1; i < Algorithms.FOR_LOOP_ATTEMPTS; i = 2*i)
            assertTrue(Algorithms.isPowerOf2(i));
        for (int i = 0; i < nonPowers.length; ++i)
            assertFalse(Algorithms.isPowerOf2(nonPowers[i]));
    }
    
    @Test
    public void testIsPowerOf4() {
        final int[] nonPowers = new int[] {-16, -4, -2, -1, 0, 2, 3, 5, 6, 7, 8, 9, 10, 11, 15, 17, 1022};
        for (int i = 1; i < Algorithms.FOR_LOOP_ATTEMPTS; i = 4*i)
            assertTrue(Algorithms.isPowerOf4(i));
        for (int i = 0; i < nonPowers.length; ++i)
            assertFalse(Algorithms.isPowerOf4(nonPowers[i]));
    }
    
    @Test
    public void testGetNumberOfBits() {
        assertTrue(Algorithms.getNumberOfBits(0) == 1);
        
        int expectedNumberOfBits = 0;
        for (int i = 1; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            if (Algorithms.isPowerOf2(i))
                expectedNumberOfBits++;
            
            assertTrue(Algorithms.getNumberOfBits(i) == expectedNumberOfBits);
            assertTrue(Algorithms.getNumberOfBits(-i) == expectedNumberOfBits + 1);
        }
    }
    
    @Test
    public void testRandInt() {
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            final int p = Algorithms.randInt(1, 9999);
            assertTrue((p > 0) && (p < 10000));
        }
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            final int p = Algorithms.randInt(-9999, -1);
            assertTrue((p < 0) && (p > -10000));
        }
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            final int p = Algorithms.randInt(0, 0);
            assertTrue(p == 0);
        }
    }
    
    @Test
    public void testRandIntFail() {
        try {
            Algorithms.randInt(0, 0, false);
            fail();
        } catch (IllegalArgumentException ex) {}
        testRandIntFail(1, 0);
        testRandIntFail(-4, -10);
    }
    
    private void testRandIntFail(final int a, final int b) {
        try {    
            Algorithms.randInt(a, b);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testRandPrime() {
        assertTrue(Algorithms.randPrime(0, 2) == 2);
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            final int p = Algorithms.randPrime(0, 10000);
            assertTrue(Algorithms.isPrime(p));
        }
    }
    
    @Test
    public void testRandPrimeFail() {
        testRandPrimeFail(10, 0);   // Max bound is smaller than min
        testRandPrimeFail(-1, 10);  // Min bound is negative
        testRandPrimeFail(0, 0);    // Max bound is smaller than 2
        testRandPrimeFail(4, 4);    // No PRIMES exist here
        testRandPrimeFail(954, 966);// And here
    }
    
    private void testRandPrimeFail(final int a, final int b) {
        try {
            Algorithms.randPrime(a, b);
            fail();
        } catch (IllegalArgumentException ex) {
        } catch (RuntimeException ex) {
        }
    }
    
    @Test
    public void testRandCoprime() {
        assertTrue(Algorithms.randCoprime(1, 1).equals(new Pair(1, 1)));
        for (int i = 0; i < Algorithms.FOR_LOOP_ATTEMPTS; ++i) {
            final Pair<Integer, Integer> coprimes = Algorithms.randCoprime(1, 500);
            assertTrue(Algorithms.isCoprime(coprimes.getFirst(), coprimes.getSecond()));
        }
    }
    
    @Test
    public void testRandCoprimeFail() {
        testRandCoprimeFail(10, 0); // Max bound is smaller than min
        testRandCoprimeFail(-1, 0); // Min bound is negative
        testRandCoprimeFail(8, 8);  // No coprimes exist here
    }
    
    private void testRandCoprimeFail(final int a, final int b) {
        try {
            Algorithms.randCoprime(a, b);
            fail();
        } catch (IllegalArgumentException ex) {
        } catch (RuntimeException ex) {
        }
    }
    
    @Test
    public void testGCD() {
        allPossibleGCDs(113, 50, 1);
        allPossibleGCDs(4864, 3458, 38);
        allPossibleGCDs(10175, 2277, 11);
        allPossibleGCDs(-15, -10, 5);
        allPossibleGCDs(1, 144, 1);
        allPossibleGCDs(1, 0, 1);
        allPossibleGCDs(0, 0, 0);
    }
    
    private void allPossibleGCDs(int a, int b, int gcd) {
        assertTrue(Algorithms.gcd(a, b) == gcd);
        assertTrue(Algorithms.gcd(-a, b) == gcd);
        assertTrue(Algorithms.gcd(a, -b) == gcd);
        assertTrue(Algorithms.gcd(-a, -b) == gcd);
        assertTrue(Algorithms.gcd(b, a) == gcd);
        assertTrue(Algorithms.gcd(-b, a) == gcd);
        assertTrue(Algorithms.gcd(b, -a) == gcd);
        assertTrue(Algorithms.gcd(-b, -a) == gcd);
    }
    
    @Test
    public void testBezout() {
        // 98 * (-1) + 21 * 5 = 7
        testBezoutHelper(98, -1, 21, 5, 7);
        testBezoutHelper(4864, 32, 3458, -45, 38);
        testBezoutHelper(15, 0, 1, 1, 1);
        testBezoutHelper(15, 1, 0, 0, 15);
        testBezoutHelper(0, 1, 0, 0, 0);
    }
    
    // ax + by = gcd;
    private void testBezoutHelper(int a, int x, int b, int y, int gcd) {
        final List<Integer> result = Algorithms.bezout(a, b);
        final List<Integer> expected = Arrays.asList(gcd, x, y);
        assertEquals(result, expected);
    }
    
    @Test
    public void testBezoutFail() {
        testBezoutFail(15, -15);
        testBezoutFail(4, 15);
    }
    
    private void testBezoutFail(final int a, final int b) {
        try {
            Algorithms.bezout(a, b);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testFactorize() {
        int n = 4864;
        ArrayList<Pair<Integer, Integer>> factors = new ArrayList<>();
        factors.add(new Pair(2, 8));
        factors.add(new Pair(19, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 3458;
        factors = new ArrayList<>();
        factors.add(new Pair(2, 1));
        factors.add(new Pair(7, 1));
        factors.add(new Pair(13, 1));
        factors.add(new Pair(19, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 1;
        factors = new ArrayList<>();
        factors.add(new Pair(1, 1));
        assertEquals(factors, Algorithms.factorize(n));
        
        n = 0;
        factors = new ArrayList<>();
        factors.add(new Pair(0, 1));
        assertEquals(factors, Algorithms.factorize(n));
    }
    
    @Test
    public void testFactorizeFail() {
        try {
            Algorithms.factorize(-15);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testEulerPhi() {
        assertTrue(Algorithms.eulerPhi(1) == 1);
        assertTrue(Algorithms.eulerPhi(25) == 20);
        assertTrue(Algorithms.eulerPhi(33) == 20);
        assertTrue(Algorithms.eulerPhi(44) == 20);
        assertTrue(Algorithms.eulerPhi(50) == 20);
        assertTrue(Algorithms.eulerPhi(66) == 20);
        assertTrue(Algorithms.eulerPhi(735) == 336);
        assertTrue(Algorithms.eulerPhi(1212) == 400);
        assertTrue(Algorithms.eulerPhi(2010) == 528);
        assertTrue(Algorithms.eulerPhi(3458) == 1296);
        assertTrue(Algorithms.eulerPhi(4864) == 2304);
    }
    
    @Test
    public void testEulerPhiFail() {
        testEulerPhiFail(-5);
        testEulerPhiFail(0);
    }
    
    private void testEulerPhiFail(final int n) {
        try {
            Algorithms.eulerPhi(n);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testNormalizeIntModulo() {
        assertTrue(Algorithms.normalizeIntModulo(8, 3) == 2);
        assertTrue(Algorithms.normalizeIntModulo(-8, 3) == 1);
        assertTrue(Algorithms.normalizeIntModulo(2, 5) == 2);
        assertTrue(Algorithms.normalizeIntModulo(-2, 5) == 3);
    }
    
    @Test
    public void testNormalizeIntModuloFail() {
        testNormalizeIntModuloFail(7, -4);
        testNormalizeIntModuloFail(7, 0);
    }
    
    private void testNormalizeIntModuloFail(final int a, final int b) {
        try {
            Algorithms.normalizeIntModulo(a, b);
            fail();
        } catch (IllegalArgumentException ex) {}
    }

    @Test
    public void testLinearCongruence() {
        testLinearCongruence(5, 7, 8, new Pair(3, 8));
        testLinearCongruence(4, 3, 7, new Pair(6, 7));
        testLinearCongruence(16, 4, 6, new Pair(1, 3));
        testLinearCongruence(21, 6, 9, new Pair(2, 3));
        testLinearCongruence(26, 4, 9, new Pair(5, 9));
        
        testLinearCongruence(3, 5, 17, new Pair(13, 17));
        testLinearCongruence(76, 8, 10, new Pair(3, 5));
        testLinearCongruence(12, 20, 28, new Pair(4, 7));
        testLinearCongruence(642, 1844, 1144, new Pair(10, 572));
        testLinearCongruence(11881376, 16, 11, new Pair(5, 11));
        
        testLinearCongruence(3, 1, 6, NO_SOLUTIONS);
        testLinearCongruence(5, 4, 5, NO_SOLUTIONS);
        
        testLinearCongruence(5, 0, 5, INFINITE_SOLUTIONS);
        testLinearCongruence(0, 3, 3, INFINITE_SOLUTIONS);
        testLinearCongruence(2, 4, 1, INFINITE_SOLUTIONS);
    }
    
    private void testLinearCongruence(final int a, final int b, final int n, final Pair<Integer, Integer> expected) {
        assertEquals(Algorithms.linearCongruence(a, b, n), expected);
    }
    
    @Test
    public void testLinearCongruenceFail() {
        testLinearCongruenceFail(12, 20, 0);
        testLinearCongruenceFail(12, 5, -14);
    }
    
    private void testLinearCongruenceFail(final int a, final int b, final int n) {
        try {
            Algorithms.linearCongruence(a, b, n);
            fail();
        } catch (IllegalArgumentException ex) {}
    }

    @Test
    public void testLinearCongruenceSystem() {
        List<Integer> aList, bList, nList;
        Pair<Integer, Integer> expected;
        
        // 2 congruences
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(6, 2));
        nList = new ArrayList<>(Arrays.asList(8, 5));
        expected = new Pair(22, 40);
        testLinearCongruenceSystem(2, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(-5, 2));
        nList = new ArrayList<>(Arrays.asList(20, 13));
        expected = new Pair(15, 260);
        testLinearCongruenceSystem(2, aList, bList, nList, expected);
        
        // 3 congruences
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(8, 5, 1));
        nList = new ArrayList<>(Arrays.asList(11, 8, 3));
        expected = new Pair(85, 264);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        /* 2x = 2 (mod 6)
           3x = 2 (mod 7)
           2x = 4 (mod 8) */
        aList = new ArrayList<>(Arrays.asList(2, 3, 2));
        bList = new ArrayList<>(Arrays.asList(2, 2, 4));
        nList = new ArrayList<>(Arrays.asList(6, 7, 8));
        expected = new Pair(10, 84);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(10, 3, 0));
        nList = new ArrayList<>(Arrays.asList(13, 12, 11));
        expected = new Pair(231, 1716);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(729, 169, 32));
        bList = new ArrayList<>(Arrays.asList(343, 27, 1331));
        nList = new ArrayList<>(Arrays.asList(5, 7, 9));
        expected = new Pair(97, 315);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(2, 4, 6));
        nList = new ArrayList<>(Arrays.asList(4, 6, 10));
        expected = new Pair(46, 60);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(2, 3, 5));
        bList = new ArrayList<>(Arrays.asList(3, 5, 7));
        nList = new ArrayList<>(Arrays.asList(5, 7, 9));
        expected = new Pair(284, 315);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 2, 5));
        nList = new ArrayList<>(Arrays.asList(7, 11, 13));
        expected = new Pair(486, 1001);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(1, 1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 1, -3));
        nList = new ArrayList<>(Arrays.asList(6, 5, 7));
        expected = new Pair(81, 210);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        /* Unsolvable */
        aList = new ArrayList<>(Arrays.asList(5));
        bList = new ArrayList<>(Arrays.asList(4));
        nList = new ArrayList<>(Arrays.asList(5));
        testLinearCongruenceSystem(1, aList, bList, nList, NO_SOLUTIONS);
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(3, 7));
        nList = new ArrayList<>(Arrays.asList(9, 15));
        testLinearCongruenceSystem(2, aList, bList, nList, NO_SOLUTIONS);
        
        aList = new ArrayList<>(Arrays.asList(1, 1));
        bList = new ArrayList<>(Arrays.asList(1, -1));
        nList = new ArrayList<>(Arrays.asList(3, 9));
        testLinearCongruenceSystem(2, aList, bList, nList, NO_SOLUTIONS);
        
        /* Infinite solutions */
        aList = new ArrayList<>(Arrays.asList(5));
        bList = new ArrayList<>(Arrays.asList(0));
        nList = new ArrayList<>(Arrays.asList(5));
        testLinearCongruenceSystem(1, aList, bList, nList, INFINITE_SOLUTIONS);
        
        aList = new ArrayList<>(Arrays.asList(0));
        bList = new ArrayList<>(Arrays.asList(3));
        nList = new ArrayList<>(Arrays.asList(3));
        testLinearCongruenceSystem(1, aList, bList, nList, INFINITE_SOLUTIONS);
        
        aList = new ArrayList<>(Arrays.asList(0, 7, 158));
        bList = new ArrayList<>(Arrays.asList(3, 14, 0));
        nList = new ArrayList<>(Arrays.asList(3, 7, 158));
        testLinearCongruenceSystem(3, aList, bList, nList, INFINITE_SOLUTIONS);
        
        /* Unsolvable, but containting equation with infinite solutions */
        aList = new ArrayList<>(Arrays.asList(7, 158, 16));
        bList = new ArrayList<>(Arrays.asList(14, 0, 5));
        nList = new ArrayList<>(Arrays.asList(7, 158, 8));
        testLinearCongruenceSystem(3, aList, bList, nList, NO_SOLUTIONS);
        
        /* Solvable, but containting equation with infinite solutions */
        aList = new ArrayList<>(Arrays.asList(2, 1, 40));
        bList = new ArrayList<>(Arrays.asList(3, 4, 40));
        nList = new ArrayList<>(Arrays.asList(5, 5, 20));
        expected = new Pair(4, 5);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
        
        aList = new ArrayList<>(Arrays.asList(40, 2, 1));
        bList = new ArrayList<>(Arrays.asList(40, 3, 4));
        nList = new ArrayList<>(Arrays.asList(20, 5, 5));
        expected = new Pair(4, 5);
        testLinearCongruenceSystem(3, aList, bList, nList, expected);
    }
    
    private void testLinearCongruenceSystem(final int count, final List<Integer> aList,
            final List<Integer> bList, final List<Integer> nList, final Pair<Integer, Integer> expected) {
        
        assertEquals(Algorithms.linearCongruenceSystem(count, aList, bList, nList), expected);
    }
    
    @Test
    public void testLinearCongruenceSystemFail() {
        List<Integer> aList = new ArrayList<>(Arrays.asList(2, 3, 2));
        List<Integer> bList = new ArrayList<>(Arrays.asList(2, 2, 4));
        List<Integer> nList = new ArrayList<>(Arrays.asList(6, 7, 0));
        try {
            Algorithms.linearCongruenceSystem(3, aList, bList, nList);
            fail();
        } catch (IllegalArgumentException ex) {}
    }

    @Test
    public void testElementsOfUnitGroup() {
        for (int i = 0; i < PRIMES.length; ++i) {
            final int n = PRIMES[i];
            List<Integer> expected = new ArrayList<>();
            for (int j = 1; j < PRIMES[i]; ++j)
                expected.add(j);
            testElementsOfUnitGroup(n, expected);
        }
        
        testElementsOfUnitGroup(4, Arrays.asList(1, 3));
        testElementsOfUnitGroup(6, Arrays.asList(1, 5));
        testElementsOfUnitGroup(8, Arrays.asList(1, 3, 5, 7));
        testElementsOfUnitGroup(12, Arrays.asList(1, 5, 7, 11));
    }
    
    private void testElementsOfUnitGroup(final int n, final List<Integer> expected) {
        final List<Integer>result = Algorithms.elementsOfUnitGroup(n);
        assertTrue(result.size() == Algorithms.eulerPhi(n));
        assertEquals(result, expected);
    }
    
    @Test
    public void testElementsOfUnitGroupFail() {
        for (int i = -2; i < 2; ++i)
            testElementsOfUnitGroupFail(i);
    }
    
    private void testElementsOfUnitGroupFail(final int n) {
        try {
            Algorithms.elementsOfUnitGroup(n);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testUnitGroupElementOrder() {
        int n = 3; // group Z3×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 2);
        
        n = 4; // group Z4×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 2);
        
        n = 5; // group Z5×
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 4);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 4);
        assertTrue(Algorithms.unitGroupElementOrder(4, n) == 2);
        
        n = 6; // group Z6×
        assertTrue(Algorithms.unitGroupElementOrder(1, n) == 1);
        assertTrue(Algorithms.unitGroupElementOrder(5, n) == 2);
        
        n = 7; // group Z7×
        assertTrue(Algorithms.unitGroupElementOrder(2, n) == 3);
        assertTrue(Algorithms.unitGroupElementOrder(3, n) == 6);
        assertTrue(Algorithms.unitGroupElementOrder(4, n) == 3);
        assertTrue(Algorithms.unitGroupElementOrder(5, n) == 6);
        assertTrue(Algorithms.unitGroupElementOrder(6, n) == 2);
        
        assertTrue(Algorithms.unitGroupElementOrder(86, 97) == 48);
    }
    
    @Test
    public void testUnitGroupElementOrderFail() {
        for (int i = -2; i < 2; ++i)
            testUnitGroupElementOrderFail(1, i);
        
        testUnitGroupElementOrderFail(-4, 5);
        testUnitGroupElementOrderFail(0, 5);
        testUnitGroupElementOrderFail(5, 5);
        testUnitGroupElementOrderFail(7, 5);
    }
    
    private void testUnitGroupElementOrderFail(final int element, final int n) {
        try {
            Algorithms.unitGroupElementOrder(element, n);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testModPow() {
        assertTrue(Algorithms.modPow(14, 15, 1) == 0);
        assertTrue(Algorithms.modPow(0, 0, 1574) == 1);
        assertTrue(Algorithms.modPow(0, 275, 1411) == 0);
        assertTrue(Algorithms.modPow(1, 557, 11889) == 1);
        assertTrue(Algorithms.modPow(-1, 557, 11889) == 11888);
        assertTrue(Algorithms.modPow(-1, 558, 11889) == 1);
        assertTrue(Algorithms.modPow(2, 6, 63) == 1);
        assertTrue(Algorithms.modPow(14, 5, 11) == 1);
        assertTrue(Algorithms.modPow(7, 144, 52) == 1);
        assertTrue(Algorithms.modPow(3, 351, 1000) == 747);
        assertTrue(Algorithms.modPow(157, 248, 369) == 160);
        assertTrue(Algorithms.modPow(-47, 25, 100) == 93);
    }
    
    @Test
    public void testModPowFail() {
        testModPowFail(14, -1, 15);
        testModPowFail(14, 1, -15);
        testModPowFail(14, -4, -815);
    }
    
    private void testModPowFail(final int b, final int e, final int m) {
        try {
            Algorithms.modPow(b, e, m);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testLegendreSymbol() {
        assertTrue(Algorithms.legendreSymbol(219, 383) == 1);
        assertTrue(Algorithms.legendreSymbol(79, 101) == 1);
        assertTrue(Algorithms.legendreSymbol(3, 59) == 1);
        assertTrue(Algorithms.legendreSymbol(49, 7) == 0);
        assertTrue(Algorithms.legendreSymbol(7, 43) == -1);
        assertTrue(Algorithms.legendreSymbol(-1, 3) == -1);
    }
    
    @Test
    public void testLegendreSymbolFail() {
        for (int i = -2; i < 3; ++i)
            testLegendreSymbolFail(14, i);
    }
    
    private void testLegendreSymbolFail(final int a, final int p) {
        try {
            Algorithms.legendreSymbol(a, p);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testQuadraticCongruenceSimple() {
        testQuadraticCongruenceSimpleMod1();
        testQuadraticCongruenceSimpleMod2();
        testQuadraticCongruenceSimpleMod3();
        testQuadraticCongruenceSimpleMod4();
        testQuadraticCongruenceSimpleMod5();
        testQuadraticCongruenceSimpleMod6();
        testQuadraticCongruenceSimpleMod7();
        testQuadraticCongruenceSimpleMod8();
        testQuadraticCongruenceSimpleMod9();
        testQuadraticCongruenceSimpleMod10();
        testQuadraticCongruenceSimpleMod11();
        testQuadraticCongruenceSimpleMod12();
        testQuadraticCongruenceSimpleMod16();
        testQuadraticCongruenceSimpleMod32();
        testQuadraticCongruenceSimpleOther();
        testQuadraticCongruenceSimpleNegative();
        testQuadraticCongruenceSimplePowersOf2();
    }
    
    private void testQuadraticCongruenceSimpleMod1() {
        List<Integer> result, expected;
        result = Algorithms.quadraticCongruenceSimple(14, 1);
        expected = new ArrayList<>(Arrays.asList(0, 1));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod2() {
        List<Integer> result, expected;
        int m = 2;
        
        // x^2 ≡ 14 (mod 2) => x ≡ 0 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(14, m);
        expected = new ArrayList<>(Arrays.asList(0, m));
        assertTrue(result.equals(expected));
        
        // x^2 ≡ 1 (mod 2) => x = 1 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, m));
        assertTrue(result.equals(expected));
        // x^2 ≡ 7 (mod 2) => x = 1 (mod 2)
        result = Algorithms.quadraticCongruenceSimple(7, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod3() {
        List<Integer> result, expected;
        int m = 3;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(15, m);
        expected = new ArrayList<>(Arrays.asList(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 2, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(7, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod4() {
        List<Integer> result, expected;
        int m = 4;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(16, m);
        expected = new ArrayList<>(Arrays.asList(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod5() {
        List<Integer> result, expected;
        int m = 5;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(15, m);
        expected = new ArrayList<>(Arrays.asList(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 4, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(101, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 3, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(54, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod6() {
        List<Integer> result, expected;
        int m = 6;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(66, m);
        expected = new ArrayList<>(Arrays.asList(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 5, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(37, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(3, m);
        expected = new ArrayList<>(Arrays.asList(3, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(39, m);
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 4, m));
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceSimple(604, m);
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod7() {
        List<Integer> result, expected;
        int m = 7;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new ArrayList<>(Arrays.asList(0, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(2, m);
        expected = new ArrayList<>(Arrays.asList(3, 4, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 5, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod8() {
        List<Integer> result, expected;
        int m = 8;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new ArrayList<>(Arrays.asList(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod9() {
        List<Integer> result, expected;
        int m = 9;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 7));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 8, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 7, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(7, m);
        expected = new ArrayList<>(Arrays.asList(4, 5, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod10() {
        List<Integer> result, expected;
        int m = 10;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 6, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 9, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 8, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(5, m);
        expected = new ArrayList<>(Arrays.asList(5, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(6, m);
        expected = new ArrayList<>(Arrays.asList(4, 6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new ArrayList<>(Arrays.asList(3, 7, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod11() {
        List<Integer> result, expected;
        int m = 11;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4, 5, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 10, m));
        assertTrue(result.equals(expected));
                
        result = Algorithms.quadraticCongruenceSimple(3, m);
        expected = new ArrayList<>(Arrays.asList(5, 6, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 9, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(5, m);
        expected = new ArrayList<>(Arrays.asList(4, 7, m));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new ArrayList<>(Arrays.asList(3, 8, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod12() {
        List<Integer> result, expected;
        int m = 12;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new ArrayList<>(Arrays.asList(0, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 5, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, 4, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new ArrayList<>(Arrays.asList(3, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod16() {
        List<Integer> result, expected;
        int m = 16;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new ArrayList<>(Arrays.asList(0, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 7, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new ArrayList<>(Arrays.asList(3, 5, m/2));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimpleMod32() {
        List<Integer> result, expected;
        int m = 32;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 4, 9, 16, 17, 25));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
                
        result = Algorithms.quadraticCongruenceSimple(0, m);
        expected = new ArrayList<>(Arrays.asList(0, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(1, m);
        expected = new ArrayList<>(Arrays.asList(1, 15, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(4, m);
        expected = new ArrayList<>(Arrays.asList(2, m/8));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(9, m);
        expected = new ArrayList<>(Arrays.asList(3, 13, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(16, m);
        expected = new ArrayList<>(Arrays.asList(4, m/4));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(17, m);
        expected = new ArrayList<>(Arrays.asList(7, 9, m/2));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceSimple(25, m);
        expected = new ArrayList<>(Arrays.asList(5, 11, m/2));
        assertTrue(result.equals(expected));
    }
    
    // Test all non residues: numbers, for which x^2 ≡ i (mod m) does not have a solution
    private void testQuadraticCongruenceSimpleNonResidues(List<Integer> residues, int m) {
        List<Integer> result;
        List<Integer> empty = new ArrayList<>();
        for (int i = 2; i < m; ++i) {
            if (residues.contains(i))
                continue;
            result = Algorithms.quadraticCongruenceSimple(i, m);
            assertTrue(result.equals(empty));
        }
    }
    
    private void testQuadraticCongruenceSimpleNonEmptySolution(List<Integer> residues, int m) {
        List<Integer> result;
        List<Integer> empty = new ArrayList<>();
        for (int i = 0; i < residues.size(); ++i) {
            result = Algorithms.quadraticCongruenceSimple(residues.get(i), m);
            assertTrue(!result.equals(empty));
        }
    }
    
    // Test non-residues from 13 up
    private void testQuadraticCongruenceSimpleOther() {
        int m = 13;
        List<Integer> residues = new ArrayList<>(Arrays.asList(0, 1, 3, 4, 9, 10, 12));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 14;
        residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4, 7, 8, 9, 11));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 15;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 6, 9, 10));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 17;
        residues = new ArrayList<>(Arrays.asList(0, 1, 2, 4, 8, 9, 13, 15, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 18;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 7, 9, 10, 13, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 19;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 6, 7, 9, 11, 16, 17));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
        
        m = 20;
        residues = new ArrayList<>(Arrays.asList(0, 1, 4, 5, 9, 16));
        testQuadraticCongruenceSimpleNonResidues(residues, m);
        testQuadraticCongruenceSimpleNonEmptySolution(residues, m);
    }
    
    private void testQuadraticCongruenceSimpleNegative() {
        List<Integer> result, expected;
        
        int m = 65;
        result = Algorithms.quadraticCongruenceSimple(-55, m);
        expected = new ArrayList<>(Arrays.asList(20, 45, m));
        assertTrue(result.equals(expected));
        
        m = 364;
        result = Algorithms.quadraticCongruenceSimple(-363, m);
        expected = new ArrayList<>(Arrays.asList(1, 27, 155, 181, m/2));
        assertTrue(result.equals(expected));
        
        m = 52;
        result = Algorithms.quadraticCongruenceSimple(-12, m);
        expected = new ArrayList<>(Arrays.asList(12, 14, m/2));
        assertTrue(result.equals(expected));
        
        m = 104;
        result = Algorithms.quadraticCongruenceSimple(-12, m);
        expected = new ArrayList<>(Arrays.asList(14, 38, m/2));
        assertTrue(result.equals(expected));
        
        m = 55;
        result = Algorithms.quadraticCongruenceSimple(-24, m);
        expected = new ArrayList<>(Arrays.asList(14, 19, 36, 41, m));
        assertTrue(result.equals(expected));
    }
    
    private void testQuadraticCongruenceSimplePowersOf2() {
        List<Integer> result, expected;
        for (int m = 2; m < 2048; m = m*2) {
            int closestPowerOf4 = Algorithms.findClosestPowerOf4(m);
            result = Algorithms.quadraticCongruenceSimple(0, m);
            expected = new ArrayList<>(Arrays.asList(0, (int)Math.sqrt(closestPowerOf4)));
            assertTrue(result.equals(expected));
        }
    }
    
    @Test
    public void testQuadraticCongruenceSimpleFail() {
        try {
            Algorithms.quadraticCongruenceSimple(14, -1);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceSimple(14, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testQuadraticCongruenceGeneral() {
        List<Integer> result, expected;
        
        // b == 0
        result = Algorithms.quadraticCongruenceGeneral(7, 0, 5, 11);
        expected = new ArrayList<>(Arrays.asList(2, 9, 11));
        assertTrue(result.equals(expected));
        
        // c == 0
        result = Algorithms.quadraticCongruenceGeneral(6, 2, 0, 5);
        expected = new ArrayList<>(Arrays.asList(0, 3, 5));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceGeneral(8, 4, 0, 17);
        expected = new ArrayList<>(Arrays.asList(0, 8, 17));
        assertTrue(result.equals(expected));
        
        // b == 0, c == 0
        result = Algorithms.quadraticCongruenceGeneral(7, 0, 0, 16);
        expected = new ArrayList<>(Arrays.asList(0, 4, 8, 12, 16));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceGeneral(5, 0, 0, 17);
        expected = new ArrayList<>(Arrays.asList(0, 17));
        assertTrue(result.equals(expected));
        
        result = Algorithms.quadraticCongruenceGeneral(3, 0, 4, 2);
        expected = new ArrayList<>(Arrays.asList(0, 2));
        assertTrue(result.equals(expected));
        
        // general
        int m = 2;
        result = Algorithms.quadraticCongruenceGeneral(3, 5, 4, m);
        expected = new ArrayList<>(Arrays.asList(0, 1, m));
        assertTrue(result.equals(expected));
        
        m = 11;
        result = Algorithms.quadraticCongruenceGeneral(5, 7, 9, m);
        expected = new ArrayList<>(Arrays.asList(6, 8, m));
        assertTrue(result.equals(expected));
        
        m = 10;
        result = Algorithms.quadraticCongruenceGeneral(9, 2, 4, m);
        expected = new ArrayList<>(Arrays.asList(6, m));
        assertTrue(result.equals(expected));
        
        m = 91;
        result = Algorithms.quadraticCongruenceGeneral(17, 35, 18, m);
        expected = new ArrayList<>(Arrays.asList(15, 41, 64, 90, m));
        assertTrue(result.equals(expected));
        
        m = 26;
        result = Algorithms.quadraticCongruenceGeneral(33, 20, 11, m);
        expected = new ArrayList<>(Arrays.asList(5, 7, m));
        assertTrue(result.equals(expected));
        
        m = 77;
        result = Algorithms.quadraticCongruenceGeneral(25, 13, 21, m);
        expected = new ArrayList<>(Arrays.asList(21, 37, 65, 70, m));
        assertTrue(result.equals(expected));
        
        // no solution
        result = Algorithms.quadraticCongruenceGeneral(8, 13, 17, 65);
        expected = new ArrayList<>();
        assertTrue(result.equals(expected));
        result = Algorithms.quadraticCongruenceGeneral(6, 8, 10, 13);
        assertTrue(result.equals(expected));
    }
    
    @Test
    public void testQuadraticCongruenceGeneralFail() {
        try {
            Algorithms.quadraticCongruenceGeneral(0, 0, 0, 0);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceGeneral(0, 0, 0, 5);
            fail();
        } catch (IllegalArgumentException ex) {}
        try {
            Algorithms.quadraticCongruenceGeneral(16, 0, 0, 32);
            fail();
        } catch (IllegalArgumentException ex) {}
    }
    
    @Test
    public void testBinomialCongruence() {
        testBinomialCongruencePower3();
        
        List<Integer> result, expected;
        int m = 529;
        result = Algorithms.binomialCongruence(5, 534, m);
        expected = new ArrayList<>(Arrays.asList(333, m));
        assertTrue(result.equals(expected));
    }
    
    private void testBinomialCongruence(int n, int a, int m, List<Integer> expected) {
        assertTrue(Algorithms.binomialCongruence(n, a, m).equals(expected));
    }
    
    private void testBinomialCongruencePower3() {
        final int n = 3;
        int m;
        
        m = 2;
        for (int a = 0; a < m; ++a)
            testBinomialCongruence(n, a, m, Arrays.asList(a, m));
        
        m = 3;
        for (int a = 0; a < m; ++a)
            testBinomialCongruence(n, a, m, Arrays.asList(a, m));
        
        m = 4;
        testBinomialCongruence(n, 0, m, Arrays.asList(0, 2, m));
        testBinomialCongruence(n, 1, m, Arrays.asList(1, m));
        testBinomialCongruence(n, 2, m, EMPTY);
        testBinomialCongruence(n, 3, m, Arrays.asList(3, m));
    }
    

}